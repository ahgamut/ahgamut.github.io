<!doctype html><html lang=en><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="https://ahgamut.github.io"><title>Patching GCC to build Actually Portable Executables | Blog Needs a Name</title><meta name=description content="Gautham's Blog"><style>*,:after,:before{box-sizing:border-box;padding:0}body{font:1.15rem '-apple-system',BlinkMacSystemFont,roboto,avenir next,avenir,ubuntu,noto,segoe ui,helvetica,helvetica neue,arial,sans-serif;text-rendering:optimizeLegibility;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;padding:2rem;background:#f5f5f5;color:#000}.figure{margin:auto}.caption{font-style:italic;font-size:small;text-align:center}.skip-link{position:absolute;top:-40px;left:0;background:#eee;z-index:100}.skip-link:focus{top:0}h1,h2,h3,h4,h5{font-size:1.35rem;font-weight:600}strong,b{font-size:inherit;font-weight:600}header{line-height:2;padding-bottom:1.5rem}.link{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;text-decoration:none}.time{font-variant-numeric:tabular-nums;white-space:nowrap}blockquote{border-left:5px solid #b4b4b4;padding-left:1rem;padding-top:.5rem;padding-bottom:.5rem;padding-right:1rem;margin:auto;background-color:#e4e4e4;font-style:italic}a,a:visited{color:inherit}a:hover,a.heading-link{text-decoration:none}ul{list-style-type:square}ul,ol{padding-left:1.2rem}.list{line-height:2;list-style-type:none;padding-left:0}.list li{padding-bottom:.1rem}.meta{color:#777}.content{max-width:70ch;margin:0 auto}header{line-height:2;display:flex;justify-content:space-between;padding-bottom:1rem}header a{text-decoration:none}header ul{list-style-type:none;padding:0}header li,header a{display:inline}h2.post{padding-top:.5rem}header ul a:first-child{padding-left:1rem}.nav{height:1px;background:#000;content:'';max-width:10%}.list li{display:flex;align-items:baseline}.list li time{flex:initial}.hr-list{margin-top:0;margin-bottom:0;margin-right:.5rem;margin-left:.5rem;height:1px;border:0;border-bottom:2px solid #ccc;flex:1 0 1rem}.m,hr{border:2px solid;margin:3rem 0}img{max-width:100%;height:auto;margin-left:auto;margin-right:auto;display:block}footer{display:table;text-align:center;margin-left:auto;margin-right:auto}table{margin-bottom:1rem;width:100%;border:1px solid #e5e5e5;border-collapse:collapse}td,th{padding:.25rem .5rem;border:1px solid #e5e5e5}pre{display:block;padding:.5rem;overflow:auto;overflow-x:scroll;overflow-wrap:normal;font-size:small;white-space:pre;margin:10px 0;padding:1rem;line-height:1.3;color:#010101;background-color:#d8d8d8}pre code{padding:0;color:inherit;background-color:inherit}code,pre{font-family:San Francisco Mono,Monaco,consolas,lucida console,dejavu sans mono,bitstream vera sans mono,monospace;font-size:small;font-style:normal}code{padding:0 5px;color:#bf616a;border-radius:3px;background-color:#d8d8d8}.chroma{background-color:#d8d8d8}.chroma .lntd{vertical-align:top;padding:0;margin:0;border:0}.chroma .lntable{border-spacing:0;padding:0;margin:0;border:0;width:auto;overflow:auto;display:block}.chroma .hl{display:block;width:100%;background-color:#ffc}.chroma .lnt{margin-right:.4em;padding:0 .4em;color:#7f7f7f}.chroma .ln{margin-right:.4em;padding:0 .4em;color:#7f7f7f}.chroma .k{color:#00f}.chroma .kc{color:#00f}.chroma .kd{color:#00f}.chroma .kn{color:#00f}.chroma .kp{color:#00f}.chroma .kr{color:#00f}.chroma .kt{color:#00f}.chroma .nc{color:#007575}.chroma .nd{color:#cc00a3}.chroma .nf{color:#c34e00}.chroma .s{color:#009c00}.chroma .sa{color:#009c00}.chroma .sb{color:#009c00}.chroma .sc{color:#009c00}.chroma .dl{color:#009c00}.chroma .sd{color:#009c00}.chroma .s2{color:#009c00}.chroma .se{color:#009c00}.chroma .sh{color:#009c00}.chroma .si{color:#009c00}.chroma .sx{color:#009c00}.chroma .sr{color:#009c00}.chroma .s1{color:#009c00}.chroma .ss{color:#009c00}.chroma .c{color:#e72f88;font-style:italic}.chroma .ch{color:#e72f88;font-style:italic}.chroma .cm{color:#e72f88;font-style:italic}.chroma .c1{color:#e72f88;font-style:italic}.chroma .cs{color:#e72f88;font-style:italic}.chroma .cp{color:#007f87}.chroma .cpf{color:#007f87}</style></head><body><a class=skip-link href=#main>Skip to main</a><main id=main><div class=content><header><p style=padding:0;margin:0><a href=/><b>Blog Needs a Name</b></a></p><ul style=padding:0;margin:0><li><a href=/>Home</a></li><li><a href=/about>About</a></li></ul></header><hr class=hr-list style=padding:0;margin:0><h2 class=post>Patching GCC to build Actually Portable Executables</h2><p><strong>2023-07-13:</strong> I wrote a <a href=https://github.com/ahgamut/gcc/tree/portcosmo-11.2>~2000-line <code>gcc</code> patch</a> to simplify building
Actually Portable Executables with <a href=https://github.com/jart/cosmopolitan>Cosmopolitan Libc</a>. Now you can build
popular software such as <code>bash</code>, <code>curl</code>, <code>git</code>, <code>ninja</code>, and even <code>gcc</code> itself,
with Cosmopolitan Libc via the <code>./configure</code> or <code>cmake</code> build system, without
having to change source code, and the built executables should run on Linux,
FreeBSD, MacOS, OpenBSD, NetBSD, and Windows too<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>. You can download
the binaries built using Github Actions here:
<a href=https://github.com/ahgamut/superconfigure/releases>https://github.com/ahgamut/superconfigure/releases</a></p><p>When Cosmopolitan Libc burst onto the scene with the <a href="https://news.ycombinator.com/item?id=26271117">Hacker News post about the
<code>redbean</code> webserver</a> in 2021, an immediate question was how existing
C software would run on it. The best way to test a new libc is to build more
code on top, and <a href=https://github.com/jart/cosmopolitan/tree/master/third_party>many codebases have been ported</a> to use cosmo. The
porting efforts have also helped fill out the libc API. However, a new libc must
also fit in with how C software is conventionally built &ndash; things like
<code>./configure</code> and <code>cmake</code> &ndash; so that porting more software is easy. When
<a href=https://github.com/jart/cosmopolitan/releases/tag/2.1><code>pthreads</code> became available last year</a>, I said: <a href=/2022/07/27/ape-rust-example/>porting is just a
matter of convincing the build system</a>. I believe my <code>gcc</code> patch is a
big step towards seamlessly building a lot of software with Cosmopolitan Libc.
This blog post will cover how the patch came to be.</p><h2 id=introduction>Introduction</h2><p><a href=https://github.com/jart/cosmopolitan/issues/61>Lua</a> was the first programming language to be ported to Cosmopolitan Libc,
followed by <a href=https://github.com/jart/cosmopolitan/issues/104>Wren</a>, <a href=https://github.com/jart/cosmopolitan/issues/114>Janet</a>, and Fabrice Bellard&rsquo;s
<a href=https://github.com/jart/cosmopolitan/issues/97#issuecomment-816831508><code>quickjs</code></a>. There appeared to be a common change across the ports:
<code>switch</code> statements with system values like <code>SIGTERM</code> or <code>EINVAL</code> had to be
rewritten as <code>if</code> statements. <strong>2021-03-24:</strong> I raised issue #134 on Github
about this, and got the below answer from <a href=https://github.com/jart>Justine Tunney</a>:</p><blockquote><p>Code that uses <code>switch</code> on system constants needs to be updated to use <code>if</code>
statements. That&rsquo;s unavoidable unfortunately. It&rsquo;s the one major breakage we
needed to make in terms of compatibility. The tradeoff is explained in the APE
blog post [&mldr;] C preprocessor macros relating to system interfaces need to be
symbolic. This is barely an issue, except in cases like <code>switch(errno){case EINVAL:}</code> If we feel comfortable bending the rules [&mldr;]</p></blockquote><p><strong>2022-09-05:</strong> After writing a bunch of ports, it was clear that the
<code>switch(errno)</code> pattern is quite common, and porting software would be much
faster if the rules could be bent automatically. I decided to try solving
<code>this</code>, but let&rsquo;s define what <code>this</code> is.</p><h2 id=switch-to-if><code>switch</code> to <code>if</code></h2><p>Consider the below code snippet:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// somewhere within your code
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>switch</span> <span class=p>(</span><span class=n>errno</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>EINVAL</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;you got EINVAL</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef EAFNOSUPPORT
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=k>case</span> <span class=nl>EAFNOSUPPORT</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1>// fallthrough
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=k>case</span> <span class=nl>ENOSYS</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;you got ENOSYS</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;unknown error</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The C standard<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> says that <code>case</code> labels need to be compile-time
constants. If <code>EINVAL</code> is not a compile-time constant, you would get an error
like <code>case label does not reduce to an integer constant</code> when compiling this
snippet with <code>gcc</code>. So you&rsquo;d need to rewrite the <code>switch</code> statement into an <code>if</code>
statement. My code rewrites <code>switch</code> statements like this:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// rewriting the switch to an if
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>{</span> <span class=c1>// maintain scoping
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span><span class=p>(</span><span class=n>errno</span> <span class=o>==</span> <span class=n>EINVAL</span><span class=p>)</span> <span class=k>goto</span> <span class=n>caselabel_EINVAL</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#ifdef EAFNOSUPPORT
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=k>if</span><span class=p>(</span><span class=n>errno</span> <span class=o>==</span> <span class=n>EAFNOSUPPORT</span><span class=p>)</span> <span class=k>goto</span> <span class=n>caselabel_EAFNOSUPPORT</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=k>if</span><span class=p>(</span><span class=n>errno</span> <span class=o>==</span> <span class=n>ENOSYS</span><span class=p>)</span> <span class=k>goto</span> <span class=n>caselabel_ENOSYS</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>goto</span> <span class=n>caselabel_default</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nl>caselabel_EINVAL</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;you got EINVAL</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>endofthis_switch</span><span class=p>;</span> <span class=c1>//  break
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#ifdef EAFNOSUPPORT
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=nl>caselabel_EAFNOSUPPORT</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=c1>// fallthrough
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=nl>caselabel_ENOSYS</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;you got ENOSYS</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>endofthis_switch</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nl>caselabel_default</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;unknown error</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>endofthis_switch</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=nl>endofthis_switch</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=p>((</span><span class=kt>void</span><span class=p>)</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The above pattern might not be the most elegant<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup> but it handles all
the examples I have seen across codebases.</p><h2 id=struct-initializations><code>struct</code> initializations</h2><p>While constructing test cases for <code>switch</code> statements that would have to be
rewritten, I came across a related problem that also assumed compile-time
constants &ndash; <code>static</code> or <code>const</code> <code>struct</code> initializations. The <a href=https://github.com/ahgamut/cpython/blob/master/Modules/faulthandler.c#L66><code>faulthandler</code>
module in CPython</a> is a real-life example of this, but let&rsquo;s look
at the below snippet:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>toy</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>status</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>value</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>func</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=n>toy</span> <span class=n>t1</span> <span class=o>=</span> 
</span></span><span class=line><span class=cl>        <span class=p>{.</span><span class=n>status</span> <span class=o>=</span> <span class=n>EINVAL</span><span class=p>,</span> <span class=p>.</span><span class=n>value</span> <span class=o>=</span> <span class=mi>25</span><span class=p>};</span> <span class=c1>// ok
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>const</span> <span class=k>struct</span> <span class=n>toy</span> <span class=n>t2</span> <span class=o>=</span> 
</span></span><span class=line><span class=cl>        <span class=p>{.</span><span class=n>status</span> <span class=o>=</span> <span class=n>EINVAL</span><span class=p>,</span> <span class=p>.</span><span class=n>value</span> <span class=o>=</span> <span class=mi>25</span><span class=p>};</span> <span class=c1>// error
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>static</span> <span class=k>struct</span> <span class=n>toy</span> <span class=n>t3</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=p>{.</span><span class=n>status</span> <span class=o>=</span> <span class=n>EINVAL</span><span class=p>,</span> <span class=p>.</span><span class=n>value</span> <span class=o>=</span> <span class=mi>25</span><span class=p>};</span> <span class=c1>// error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>const</span> <span class=k>struct</span> <span class=n>toy</span> <span class=n>gt2</span> <span class=o>=</span> 
</span></span><span class=line><span class=cl>    <span class=p>{.</span><span class=n>status</span> <span class=o>=</span> <span class=n>EINVAL</span><span class=p>,</span> <span class=p>.</span><span class=n>value</span> <span class=o>=</span> <span class=mi>25</span><span class=p>};</span> <span class=c1>// error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=k>struct</span> <span class=n>toy</span> <span class=n>gt3</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=p>{.</span><span class=n>status</span> <span class=o>=</span> <span class=n>EINVAL</span><span class=p>,</span> <span class=p>.</span><span class=n>value</span> <span class=o>=</span> <span class=mi>25</span><span class=p>};</span> <span class=c1>// error
</span></span></span></code></pre></div><p>If <code>EINVAL</code> is not a compile-time constant, four of the initializations above
are not valid<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup> in C. My fix was to dummy-initialize the <code>struct</code>s and
then add an <code>if</code> statement or an <a href=https://gcc.gnu.org/onlinedocs/gcc-11.2.0/gcc/Common-Function-Attributes.html#Common-Function-Attributes><code>__attribute__((constructor))</code></a> to fill
in the correct value(s) before they are used at runtime.</p><h2 id=outline-of-the-problem>Outline of the problem</h2><p>From the above two sections we have defined the problem space: certain <code>switch</code>
statements and <code>struct</code> initializations may not compile, because they rely on
system values being compile-time constants. Now:</p><ul><li>Can we (automatically) find these <code>switch</code> statements and convert them into
<code>if</code>s and <code>goto</code>s?</li><li>Can we (automatically) find these <code>struct</code> initializations and insert the
necessary code that fills in the correct runtime values?</li></ul><p>I started off trying to automate these conversions using <code>sed</code> in a shell
script. After a while, it was a python script with some extra regex work to
handle <code>switch</code> fallthroughs. But neither of these worked completely because of
the C preprocessor and <code>ifdef</code>s. It is difficult to perform the rewrite as a
<em>text substitution</em> when you do not know which <code>ifdef</code>s would activate during
compilation. Then, maybe I could perform the rewrite as an <em>AST substitution</em> &ndash;
if the code was available as an AST (abstract syntax tree), performing a rewrite
would be replacing one subtree with another. I could also avoid dealing with
the C preprocessor&mldr;</p><h2 id=curiously-exploring-gcc-plugins>Curiously exploring <code>gcc</code> plugins</h2><p><code>gcc</code> provides a plugin architecture via which you can access the AST of the
code being compiled. You compile your code as a shared object, load it alongside
<code>gcc</code> with the flag <code>-fplugin=your-plugin.so</code>. The <a href=https://gcc.gnu.org/onlinedocs/gcc-11.2.0/gccint/><code>gcc</code> internals
documentation</a> provides detailed explanations as to when and how the
plugin writers can interact with the compilation process, and there are some
<a href=https://jongy.github.io/2020/04/25/gcc-assert-introspect.html>wonderful</a> <a href=https://gabrieleserra.ml/blog/2020-08-27-an-introduction-to-gcc-and-gccs-plugins.html>articles</a> with examples of how you can write your own
<code>gcc</code> plugins (perhaps I should write my own article with examples). For now,
let&rsquo;s just remember the following:</p><ol><li><code>gcc</code> allows plugins to activate callbacks during <a href=https://gcc.gnu.org/onlinedocs/gcc-11.2.0/gccint/Plugin-API.html#Plugin-API>plugin events</a>:</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>enum</span> <span class=n>plugin_event</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>PLUGIN_START_PARSE_FUNCTION</span><span class=p>,</span>  <span class=cm>/* Called before parsing the body of a function. */</span>
</span></span><span class=line><span class=cl>  <span class=n>PLUGIN_FINISH_PARSE_FUNCTION</span><span class=p>,</span> <span class=cm>/* After finishing parsing a function. */</span>
</span></span><span class=line><span class=cl>  <span class=n>PLUGIN_FINISH_DECL</span><span class=p>,</span>           <span class=cm>/* After finishing parsing a declaration. */</span>
</span></span><span class=line><span class=cl>  <span class=n>PLUGIN_PRE_GENERICIZE</span><span class=p>,</span>        <span class=cm>/* Allows to see low level AST in C and C++ frontends.  */</span>
</span></span><span class=line><span class=cl>  <span class=n>PLUGIN_INFO</span><span class=p>,</span>                  <span class=cm>/* Information about the plugin. */</span>
</span></span><span class=line><span class=cl>  <span class=n>PLUGIN_INCLUDE_FILE</span><span class=p>,</span>          <span class=cm>/* Called when a file is #include-d */</span>
</span></span><span class=line><span class=cl>  <span class=cm>/* [removed some of the events] */</span>
</span></span><span class=line><span class=cl>  <span class=n>PLUGIN_START_UNIT</span><span class=p>,</span>            <span class=cm>/* Called before processing a translation unit.  */</span>
</span></span><span class=line><span class=cl>  <span class=n>PLUGIN_FINISH_UNIT</span><span class=p>,</span>           <span class=cm>/* Useful for summary processing.  */</span>
</span></span><span class=line><span class=cl>  <span class=n>PLUGIN_FINISH</span>                 <span class=cm>/* Called before GCC exits.  */</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>The callback is provided some data from <code>gcc</code> (which may be a pointer to an AST,
a string, or something else depending on the event), and a pointer to data that
you might have initialized at startup. Since we need to manipulate the AST, the
<code>PLUGIN_PRE_GENERICIZE</code>, <code>PLUGIN_FINISH_PARSE_FUNCTION</code>, or <code>PLUGIN_FINISH_DECL</code>
events seem viable.</p><ol start=2><li><p>The AST provided by <code>gcc</code> is a tree structure, which takes a while to connect
to the original C code, but is easy to read and manipulate afterwards. <code>gcc</code>
provides a function called <code>debug_tree</code> that prints the AST. It&rsquo;s probably
the function you will use the most when developing a plugin. There are also
convenient macros to access, say, the second arg of the <code>ADD_EXPR</code> or the
name of the <code>VAR_DECL</code>.</p></li><li><p><code>gcc</code> provides a function <code>walk_tree_without_duplicates(ast, your_callback, your_data)</code> which walks through the entire AST in pre-order traversal and
presents each node to <code>your_callback</code> to read, process, and modify.</p></li></ol><p><strong>2022-12-27:</strong> I set up a <a href=https://github.com/ahgamut/cosmo-gcc-plugin/tree/3389ca1afd736af9ba187086d0896e0680312923><code>gcc</code> plugin</a> that would activate on
<code>PLUGIN_PRE_GENERICIZE</code> and walk through the AST looking for <code>switch</code> statements
to rewrite. Simple enough, seemed like it would work, so I tried the below
example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>switch</span><span class=p>(</span><span class=n>errval</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=mi>0</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>case</span> <span class=nl>SIGTERM</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;you got a SIGTERM</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>        <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;unknown error</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>But:</p><pre tabindex=0><code class=language-gcc data-lang=gcc>examples/ex1_modded.c: In function ‘exam_func’:
examples/ex1_modded.c:25:5: 
   error: case label does not reduce to an integer constant
   25 |     case SIGTERM:
      |     ^~~~
</code></pre><p><code>gcc</code> is still raising an error due to the <code>case</code> label? Why does the plugin not
activate? I check the AST with <code>debug_tree</code>, and <code>case 0:</code> was there:</p><pre tabindex=0><code>&lt;switch_stmt
   arg:0 &lt;parm_decl errval&gt;
   arg:1 &lt;statement_list type &lt;void_type void&gt;
     stmt &lt;case_label_expr type &lt;void_type void&gt;
         arg:0 &lt;integer_cst constant 0&gt; arg:2 &lt;label_decl D.2390&gt;&gt;
     stmt &lt;break_stmt type &lt;void_type void&gt;&gt;
</code></pre><p>But <code>case SIGTERM:</code>?</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=line><span class=cl>     stmt <span class=p>&lt;</span><span class=nt>call_expr</span> <span class=na>type</span> <span class=err>&lt;</span><span class=na>integer_type</span> <span class=na>int</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>         side-effects
</span></span><span class=line><span class=cl>         fn <span class=p>&lt;</span><span class=nt>addr_expr</span> <span class=na>type</span> <span class=err>&lt;</span><span class=na>pointer_type</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>             constant arg:0 <span class=p>&lt;</span><span class=nt>function_decl</span> <span class=na>printf</span><span class=p>&gt;</span>&gt;
</span></span><span class=line><span class=cl>         arg:0 <span class=p>&lt;</span><span class=nt>nop_expr</span> <span class=na>type</span> <span class=err>&lt;</span><span class=na>pointer_type</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>           arg:0 <span class=p>&lt;</span><span class=nt>addr_expr</span> <span class=na>type</span> <span class=err>&lt;</span><span class=na>pointer_type</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>             arg:0 <span class=p>&lt;</span><span class=nt>string_cst</span> <span class=na>type</span> <span class=err>&lt;</span><span class=na>array_type</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>                readonly constant static &#34;you got a SIGTERM\012\000&#34;&gt;&gt;&gt;
</span></span><span class=line><span class=cl>     stmt <span class=p>&lt;</span><span class=nt>break_stmt</span> <span class=na>type</span> <span class=err>&lt;</span><span class=na>void_type</span> <span class=na>void</span><span class=p>&gt;</span>&gt;
</span></span></code></pre></div><p>There was no <code>case</code> label to rewrite! I checked my code and all of the build
config for building the plugin, but I always got an invalid AST, and a <code>switch</code>
statement without the (incorrect) <code>case</code> label that I wanted to rewrite.</p><p>After a while watching the errors repeat, I found out that the plugin can access
the AST only <em>after</em> <code>gcc</code> had finished parsing the source file, and the <code>case</code>
label validation happens <em>during</em> the parsing process. I can&rsquo;t fix the <code>switch</code>
case without knowing the value of the <code>case</code> label, and even then, the error
raised by <code>gcc</code> earlier would still mean the compilation fails.</p><p>Was this the end?</p><h2 id=return-of-the-c-preprocessor>Return of the C preprocessor</h2><p><strong>2023-03-14:</strong> <code>PLUGIN_PRE_GENERICIZE</code> only received an AST after parsing, and
but <code>gcc</code> gave me an invalid AST due to the <code>switch</code> statement. I needed to
ensure a valid AST before I could rewrite it, and one way to interact with the
code before parsing is &mldr; with the C preprocessor! Could I interact with the C
preprocessor from within the plugin? Yes! The <code>gcc</code> plugin headers provide a
structure called <code>cpp_reader</code>, within which you can define custom callbacks that
activate when a macro is <code>#define</code>&rsquo;d, <code>#undef</code>&rsquo;d, and used! I still don&rsquo;t
understand exactly how <code>cpp_reader</code> works, but now there was another line of
attack:</p><ul><li>Cosmopolitan Libc (used to) provide macros for system values like below, so
that the <code>#ifdef</code> checks would not complain:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>extern</span> <span class=k>const</span> <span class=kt>int</span> <span class=n>SIGTERM</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#define SYMBOLIC(X) X
</span></span></span><span class=line><span class=cl><span class=cp>#define SIGTERM SYMBOLIC(SIGTERM)
</span></span></span></code></pre></div><ul><li>With a custom header file, I could create a temporary value like:</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>static</span> <span class=k>const</span> <span class=kt>int</span> <span class=n>__tmpcosmo_SIGTERM</span> <span class=o>=</span> <span class=mi>3141592</span><span class=p>;</span>
</span></span></code></pre></div><ul><li><p>and then within my plugin code, I could <em>intercept the usage of the macro
<code>SYMBOLIC(SIGTERM)</code> and substitute my temporary value instead</em>, so that the
parsing would not error out.</p></li><li><p>Finally, with a valid AST in <code>PLUGIN_PRE_GENERICIZE</code>, I could <em>look up the
specific line of code where I did the interception</em> and rewrite the AST with
the correct <code>VAR_DECL</code> of <code>SIGTERM</code> instead of the temporary value.</p></li></ul><p>Let me repeat: a <code>#define</code> in Cosmopolitan Libc headers, a temporary <code>static const</code> in my custom header, a macro interception in the plugin, followed by an
AST rewrite in the plugin. In terms of code outside the compiler:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// Cosmopolitan Libc provided
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>extern</span> <span class=k>const</span> <span class=kt>int</span> <span class=n>ENOSYS</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#define ENOSYS SYMBOLIC(ENOSYS)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=c1>// for the plugin-macro-hack
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>static</span> <span class=k>const</span> <span class=kt>int</span> <span class=n>__tmpcosmo_ENOSYS</span> <span class=o>=</span> <span class=mi>1209372</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#define SYMBOLIC(ENOSYS) __tmpcosmo_ENOSYS
</span></span></span></code></pre></div><p>Then the plugin would latch on to the temporary constants, and perform the AST
rewrites. It sounds ridiculous, <a href=https://github.com/ahgamut/cosmo-gcc-plugin/commit/8ddce89551eadb6ea19ab843a71876cd75340edc>but it <em>worked</em></a>. Within that
week, I had a plugin that successfully worked around both the <code>switch</code>-<code>case</code>
and the <code>struct</code> initialization errors, which I could verify with a bunch of
simple examples. <strong>2023-03-26:</strong> I got a minimal <a href=https://github.com/ahgamut/cpython/tree/py311-custom>CPython 3.11</a>
building with this macro hack. There were a few issues, but at this point the
experiment had a decent chance of success, so I asked Justine if we could use
this plugin when building software with Cosmopolitan Libc.</p><h2 id=why-not-just-patch-gcc>Why not just patch <code>gcc</code>?</h2><p>The common theme in my discussion with Justine was: now that we know the problem
can be solved, is there a simpler way to solve the problem? She suggested I not
bother using plugin APIs, work on the GCC codebase itself, and simply change
whatever I needed. I was initially hesitant<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup>, but the edge cases and
crashes with the macro-hack arrangement got wackier<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup> , due to lots of
extra unnecessary work. Here&rsquo;s an example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>extern</span> <span class=k>const</span> <span class=kt>int</span> <span class=n>ENOSYS</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cm>/* for the plugin */</span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>const</span> <span class=kt>int</span> <span class=n>__tmpcosmo_ENOSYS</span> <span class=o>=</span> <span class=mi>172389</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=cp>#define SYMBOLIC(ENOSYS) __tmpcosmo_ENOSYS
</span></span></span><span class=line><span class=cl><span class=cp>#define ENOSYS SYMBOLIC(ENOSYS)
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>foo</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>switch</span><span class=p>(</span><span class=n>errno</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>case</span> <span class=nl>ENOSYS</span><span class=p>:</span>                        <span class=c1>// necessary to rewrite
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=kt>int</span> <span class=n>x</span> <span class=o>=</span> <span class=n>ENOSYS</span> <span class=o>+</span> <span class=mi>1</span><span class=p>;</span>             <span class=c1>// EXTRA WORK
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;ENOSYS = %d&#34;</span><span class=p>,</span> <span class=n>ENOSYS</span><span class=p>);</span>  <span class=c1>// EXTRA WORK
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>return</span> <span class=n>x</span><span class=p>;</span>                       <span class=c1>// EXTRA WORK
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>default</span><span class=o>:</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>The only error that <code>gcc</code> would raise without the plugin is the <code>case ENOSYS</code>,
and the plugin can handle that. However, the macro substitution due to
<code>ACTUALLY(ENOSYS)</code> meant that the plugin also had to handle every other (valid)
use of <code>ENOSYS</code>, which could (hopefully) be avoided by patching <code>gcc</code> instead.</p><p>It took a while to figure out where to add my code into the <code>gcc</code> source tree,
but the overall design of the plugin became simpler. Instead of <code>-fplugin</code>, the
code was now activated with a compiler flag <code>-fportcosmo</code>. To my great relief,
I could delete all my macro-related hacks. Now I could just intercept the parser
error instead: right before <code>gcc</code> raised a <code>case is not constant</code> error, check
if <code>flag_portcosmo</code> is active, and if yes, perform the necessary substitution.
The AST rewriting code was a copy-paste from the plugin, and it was executed
by <code>gcc</code> right before invoking other plugin callbacks.</p><h2 id=porting-software-with-the-patched-gcc>Porting software with the patched <code>gcc</code></h2><p><strong>2023-06-05:</strong> At this stage, the patched <code>gcc</code> was passing all the test cases
I had written for the plugin earlier, and new binaries were added into the
Cosmopolitan Libc monorepo. This allowed for compiling a lot more code, leading
to fixes and improvements. Building <code>lua</code> was now straightforward, and I found
out where <code>g++</code> raised the <code>case constant</code> error so <code>ninja</code> could build. I
wanted <a href=https://github.com/ahgamut/cpython/tree/portcosmo>Python3.11</a> to have <code>ncurses</code>, so I tried building that next.
<code>ncurses</code> had <a href=https://github.com/mirror/ncurses/blob/master/ncurses/trace/lib_tracebits.c#L151>something interesting</a>:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>unsigned</span> <span class=kt>int</span> <span class=n>val</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>const</span> <span class=kt>char</span> <span class=n>name</span><span class=p>[</span><span class=n>BITNAMELEN</span><span class=p>];</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=n>BITNAMES</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=cp>#define DATA(name)        { name, { #name } }
</span></span></span><span class=line><span class=cl><span class=cp>#define DATA2(name,name2) { name, { #name2 } }
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>static</span> <span class=k>const</span> <span class=n>BITNAMES</span> <span class=n>cflags</span><span class=p>[]</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nf>DATA</span><span class=p>(</span><span class=n>CLOCAL</span><span class=p>),</span>
</span></span><span class=line><span class=cl>	<span class=nf>DATA</span><span class=p>(</span><span class=n>CREAD</span><span class=p>),</span>
</span></span><span class=line><span class=cl>	<span class=nf>DATA</span><span class=p>(</span><span class=n>CSTOPB</span><span class=p>),</span>
</span></span><span class=line><span class=cl><span class=cp>#if !defined(CS5) || !defined(CS8)
</span></span></span><span class=line><span class=cl><span class=cp></span>	<span class=nf>DATA</span><span class=p>(</span><span class=n>CSIZE</span><span class=p>),</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp></span>	<span class=nf>DATA</span><span class=p>(</span><span class=n>HUPCL</span><span class=p>),</span>
</span></span><span class=line><span class=cl>	<span class=nf>DATA</span><span class=p>(</span><span class=n>PARENB</span><span class=p>),</span>
</span></span><span class=line><span class=cl>	<span class=nf>DATA2</span><span class=p>(</span><span class=n>PARODD</span> <span class=o>|</span> <span class=n>PARENB</span><span class=p>,</span> <span class=n>PARODD</span><span class=p>),</span>
</span></span><span class=line><span class=cl>	<span class=nf>DATAX</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=cp>#define ALLCTRL	(CLOCAL|CREAD|CSIZE|CSTOPB|HUPCL|PARENB|PARODD)
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=p>};</span>
</span></span></code></pre></div><p>Now <code>PARENB</code> and <code>PARODD</code> were <code>extern const</code> values in
Cosmopolitan Libc, and my patch was fixing the <code>struct</code> initialization for
<code>DATA(PARENB)</code> as expected, but it was getting stuck with:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// DATA2(PARODD | PARENB, PARODD) evaluates to
</span></span></span><span class=line><span class=cl><span class=c1></span> <span class=p>{.</span><span class=n>val</span> <span class=o>=</span> <span class=n>PARODD</span> <span class=o>|</span> <span class=n>PARENB</span><span class=p>,</span> <span class=p>.</span><span class=n>name</span> <span class=o>=</span> <span class=s>&#34;PARODD&#34;</span><span class=p>},</span> <span class=c1>// unable to rewrite
</span></span></span></code></pre></div><p>The <code>struct</code> initialization for <code>PARODD</code> had a <em>binary expression</em>, instead of
the usual constants, and my patch had no code to handle that. I thought about it
for a while, and decided situations like this would occur frequently enough
where it would be convenient to handle them automatically. I added a change
allowing <code>case</code> labels and <code>struct</code> initializer elements in C<sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup> to be
<em>arbitrary expressions</em>, which means you can compile things like:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl> <span class=c1>// C does NOT allow this, but with -fportcosmo...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>case</span> <span class=p>(</span><span class=nf>foo</span><span class=p>(</span><span class=n>SIGTERM</span><span class=p>)</span> <span class=o>+</span> <span class=nf>bar</span><span class=p>(</span><span class=n>SIGTERM</span><span class=p>))</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>toy</span> <span class=n>t</span> <span class=o>=</span> 
</span></span><span class=line><span class=cl>    <span class=p>{.</span><span class=n>status</span> <span class=o>=</span> <span class=p>(</span><span class=nf>foo</span><span class=p>(</span><span class=n>SIGTERM</span><span class=p>)</span> <span class=o>+</span> <span class=nf>bar</span><span class=p>(</span><span class=n>ENOSYS</span><span class=p>)),</span> <span class=n>value</span> <span class=o>=</span> <span class=mi>22</span><span class=p>};</span>
</span></span></code></pre></div><p>With that, <code>ncurses</code> built without a complaint. Note that the C standard allows
<code>case</code> labels to only be compile-time constants, and my patched compiler will
still raise a warning when you do something like this, but otherwise&mldr;</p><p><img src=/images/patch-gcc/portal_gun.webp alt loading=lazy decoding=async width height class=full-width></p><p class=caption><code>./configure</code> flags, run <code>make</code> and ... you got it! you f****** got it!</p><h2 id=closing-notes>Closing Notes</h2><p><strong>2023-07-13:</strong> To port software to Cosmopolitan Libc, you just need to convince
the build system. I mentioned this last year, and this <code>gcc</code> patch experiment
was to reduce the amount of convincing you would need to do. One of the
motivations for this experiment was to find an answer to the question &ldquo;what is
the minimum amount of source code that would need to change in order to port
something to Cosmopolitan Libc?&rdquo; I am glad to find out that the answer is less
than ten lines in most cases, and could even be zero.</p><p>Of course, my patch isn&rsquo;t perfect. It can&rsquo;t handle some anonymous structs,
<code>enum</code>s, <code>const int</code>s, or amazing things like <a href=https://github.com/mirror/busybox/blob/2d4a3d9e6c1493a9520b907e07a41aca90cdfd94/libbb/u_signal_names.c#L88>using <code>SIGTERM</code> as an array index
within an initializer</a>. Rare compiler crashes may still occur in
some weird <code>static</code> initializations, or if you try stuffing <code>SIGTERM</code> into a
<code>static const int8_t</code>. But I&rsquo;ve spent a good chunk of time removing obvious
counterexamples, and a lot of popular software builds seamlessly. A stringent
testing setup will reveal more things to improve.</p><p>If you prefer, you can still rewrite the <code>switch</code> statements and <code>struct</code>
initializers by hand, but for many cases the compiler can do it for you, and all
that is necessary for a port is to specify the right flags to <code>./configure</code> or
<code>cmake</code>. If you can build your C software statically (bonus points if it builds
with <code>musl</code>), there&rsquo;s a decent chance it builds with Cosmopolitan Libc right
now. Just try to build it! There are lots of possibilities.</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>I haven&rsquo;t tested running these executables on Windows, because I don&rsquo;t
currently have a computer running Windows. Let me know what happens if you
run the Actually Portable versions of <code>bash</code>, <code>curl</code>, or <code>git</code> on Windows.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>Check out Section 6.8.4.2 of the C standard at <a href=https://www.open-std.org/jtc1/sc22/wg14/www/C99RationaleV5.10.pdf>this pdf</a>. I
believe a similar description of <code>switch</code> statements is provided for C11 and
C17.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>Indeed, &ldquo;<code>goto</code> is considered harmful&rdquo; but I offer the following counters: I
believe the simplest automatic way to rewrite <code>switch</code> statements (with
<code>ifdef</code>s and fallthroughs mixed in) is to use <code>goto</code> statements, because
otherwise you have to do some algebra in the condition of the <code>if</code>
statement. Also technically, I&rsquo;m not telling <em>you</em> to write <code>goto</code>
statements, I&rsquo;m telling <code>gcc</code> to convert your <code>switch</code> case labels into the
<code>goto</code> target labels they actually are. So in a way I&rsquo;m ensuring that you
have to write less <code>goto</code> statements overall.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>Thus we have a difference between C/C++. As I found out recently while
trying to patch <code>g++</code>, C++ does not seem to care that <code>struct</code>
initializations have non-<code>static</code> constants: as far as I know, all of
the initializations above are valid in C++ (as long as you have the order of
members correct). Now <code>constexpr</code> though, that&rsquo;s a totally different story.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>Writing plugins is a good introduction into the <code>gcc</code> source; when debugging
a plugin crash, I found it useful to read the implementations of functions
that were declared in the <code>gcc</code> headers, eventually tracing the logic error
back to my own code. The <code>gcc</code> source is C++, but I&rsquo;d say it looks more like
&ldquo;C-with-templates&rdquo;, which are my favorite parts of C++ anyway. Also, <code>gcc</code>
doesn&rsquo;t seem to use the C++ STL anywhere &ndash; they have their own internal
vector/hash table implementations. Lots to learn: I finally got a
nonzero understanding of traits after using them for a hash table in <code>gcc</code>.&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p>I&rsquo;d like to introduce a new term into <code>gcc</code> plugin development, called the
&ldquo;segfault deadlock&rdquo;. A segfault deadlock is a situation where one alternates
between segfaults from the compiler when compiling <code>foo.c</code> and segfaults
from running the code generated by compiling <code>foo.c</code>.&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7><p>I specifically excluded C++ here because my arbitary expression substitution
does not play well with the <code>constexpr</code> stuff in <code>g++11</code>. I don&rsquo;t get how
<code>g++11</code> does <code>constexpr</code> &ndash; I know where the code is, and I see some sort of
recursive tree-walking happening, but I&rsquo;m not as comfortable with it yet.
Did you know <code>g++11</code> attempts to <code>constexpr</code> the <code>case</code> values within a
<code>switch</code>, and that it&rsquo;s done differently compared to C? I didn&rsquo;t, I thought
<code>switch</code> statements would be parsed in the same way for C and C++.&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div><hr style="border:1px solid"></div></main><footer>Copyright © 2023 Gautham Venkatasubramanian
<img style=visibility:hidden src="https://ipv4.games/claim?name=ahgamut"></footer></body></html>